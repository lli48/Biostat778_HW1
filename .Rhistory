#define function
fastlm<-function(X, y, na.rm = FALSE)
{
n<-length(y)
p<-ncol(X)
# calculating transpose(X)%*%X
A<-crossprod(X)
C<-crossprod(X,y)
#cholesky decomposition
Q<-chol(A)
#solve betahat
temp1<-forwardsolve(t(Q),C)
betahat<-backsolve(Q,temp1)
#calculate covirance of beta
cov_beta<-chol2inv(Q)*as.numeric(crossprod(y-X%*%betahat)/(n-p))
return(list(coeffients=betahat,vcov=cov_beta))
}
set.seed(2)
## Generate predictor matrix
n <- 100000
p <- 500
X <- cbind(1, matrix(rnorm(n * (p - 1)), n, p - 1))
## Coefficents
b <- rnorm(p)
## Response
y <- X %*% b + rnorm(n)
system.time(fit<-fastlm(X, y))
Z=cbind(X,y)
X=X[complete.cases(Z),]
y=as.matrix(y[complete.cases(Z)])
y=y[complete.cases(Z)]
#define function
fastlm<-function(X, y, na.rm = FALSE)
{
n<-length(y)
p<-ncol(X)
##check na.rm
if (na.rm==TRUE){
Z=cbind(X,y)
X=X[complete.cases(Z),]
y=as.matrix(y[complete.cases(Z)])
}
# calculating transpose(X)%*%X
A<-crossprod(X)
C<-crossprod(X,y)
#cholesky decomposition
Q<-chol(A)
#solve betahat
temp1<-forwardsolve(t(Q),C)
betahat<-backsolve(Q,temp1)
#calculate covirance of beta
cov_beta<-chol2inv(Q)*as.numeric(crossprod(y-X%*%betahat)/(n-p))
return(list(coeffients=betahat,vcov=cov_beta))
}
set.seed(2)
## Generate predictor matrix
n <- 100000
p <- 500
X <- cbind(1, matrix(rnorm(n * (p - 1)), n, p - 1))
## Coefficents
b <- rnorm(p)
## Response
y <- X %*% b + rnorm(n)
fit <- fastlm(X, y)
str(fit)
system.time(fit<-fastlm(X, y))
#Define function Fast Multivariate Normal Density
dmvnorm <- function(x, mu, S, log = TRUE) {
k=length(mu)
n=nrow(x)
#Check positive definite
Q=tryCatch({chol(S)},
error=function(error){
message("S is not positive definite matrix")
})
#
temp1=x-rep(1,n)%*%t(mu)
C=forwardsolve(t(Q),t(temp1))
temp2=diag(crossprod(C))
logdensity=(-k/2)*log(2*pi)-(1/2)*2*sum(log(diag(Q)))-(1/2)*temp2
if(log==FALSE){
logdensity=exp(logdensity)
}
return(logdensity)
}
## Create the covariance matrix
n <- 10
n2 <- n^2
xg <- seq(0, 1, length = n)
yg <- xg
g <- data.matrix(expand.grid(xg, yg))
D <- as.matrix(dist(g))
phi <- 5
S <- exp(-phi * D)
mu <- rep(0, n2)
set.seed(1)
x <- matrix(rnorm(n2), byrow = TRUE, ncol = n2)
source("dmvnorm.R")
dmvnorm(x, mu, S, log = TRUE)
#Define function Fast Multivariate Normal Density
dmvnorm <- function(x, mu, S, log = TRUE) {
k=length(mu)
n=nrow(x)
#Check positive definite
Q=tryCatch({chol(S)},
error=function(error){
message("S is not positive definite matrix")
})
#
temp1=x-rep(1,n)%*%t(mu)
C=forwardsolve(t(Q),t(temp1))
temp2=diag(crossprod(C))
logdensity=(-k/2)*log(2*pi)-(1/2)*2*sum(log(diag(Q)))-(1/2)*temp2
if(log==FALSE){
logdensity=exp(logdensity)
}
return(logdensity)
}
## Create the covariance matrix
n <- 100
n2 <- n^2
xg <- seq(0, 1, length = n)
yg <- xg
g <- data.matrix(expand.grid(xg, yg))
D <- as.matrix(dist(g))
phi <- 5
S <- exp(-phi * D)
mu <- rep(0, n2)
set.seed(1)
x <- matrix(rnorm(n2), byrow = TRUE, ncol = n2)
dmvnorm(x, mu, S, log = TRUE)
pi
